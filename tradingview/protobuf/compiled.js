// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

var Msg = exports.Msg = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var qsd = exports.qsd = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var set_auth_token = exports.set_auth_token = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineMsg()
defineqsd()
defineset_auth_token()

function defineMsg () {
  Msg.Commands = {
  "chart_create_session": 0,
  "chart_delete_session": 1,
  "resolve_symbol": 2,
  "create_series": 3,
  "create_study": 4,
  "message": 5,
  "timescale_update": 6,
  "du": 7,
  "series_loading": 8,
  "series_completed": 9,
  "series_error": 10,
  "series_deleted": 11,
  "series_timeframe": 12,
  "first_bar_time": 13,
  "study_loading": 14,
  "study_completed": 15,
  "switch_timezone": 16,
  "request_studies_metadata": 17,
  "remove_series": 18,
  "modify_series": 19,
  "request_more_data": 20,
  "get_first_bar_time": 21,
  "create_child_study": 22,
  "remove_study": 23,
  "modify_study": 24,
  "create_pointset": 25,
  "symbol_resolved": 26,
  "study_deleted": 27,
  "protocol_error": 28,
  "critical_error": 29,
  "set_auth_token": 30,
  "studies_metadata": 31,
  "set_data_quality": 32,
  "quote_create_session": 33,
  "quote_set_fields": 34,
  "quote_delete_session": 35,
  "quote_add_symbols": 36,
  "quote_remove_symbols": 37,
  "quote_switch_timezone": 38,
  "quote_fast_symbols": 39,
  "quote_hibernate_all": 40,
  "qsd": 41,
  "quote_list_fields": 42,
  "depth_create_session": 43,
  "depth_delete_session": 44,
  "depth_set_symbol": 45,
  "depth_clear_symbol": 46,
  "depth_set_scale": 47,
  "depth_symbol_success": 48,
  "depth_symbol_error": 49,
  "depth_symbol_cleared": 50,
  "dd": 51,
  "depth_bar_last_value": 52,
  "remove_pointset": 53,
  "study_error": 54,
  "modify_pointset": 55,
  "switch_protocol": 56,
  "symbol_error": 57,
  "request_more_tickmarks": 58,
  "tickmark_update": 59,
  "error_message": 60,
  "wrong_message_type": 61,
  "mock_fire_tick": 62,
  "pointset_error": 63,
  "quote_fire_tick": 64,
  "quote_fire_crash": 65,
  "child_study_rebind": 66
}

  var enc = [
    encodings.enum,
    encodings.bytes
  ]

  Msg.encodingLength = encodingLength
  Msg.encode = encode
  Msg.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.command_number)) {
      var len = enc[0].encodingLength(obj.command_number)
      length += 1 + len
    }
    if (defined(obj.data)) {
      var len = enc[1].encodingLength(obj.data)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.command_number)) {
      buf[offset++] = 8
      enc[0].encode(obj.command_number, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.data)) {
      buf[offset++] = 18
      enc[1].encode(obj.data, buf, offset)
      offset += enc[1].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      command_number: 0,
      data: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.command_number = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 2:
        obj.data = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineqsd () {
  var enc = [
    encodings.string,
    encodings.double,
    encodings.float
  ]

  qsd.encodingLength = encodingLength
  qsd.encode = encode
  qsd.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.session)) {
      var len = enc[0].encodingLength(obj.session)
      length += 1 + len
    }
    if (defined(obj.symbol_name)) {
      var len = enc[0].encodingLength(obj.symbol_name)
      length += 1 + len
    }
    if (defined(obj.status)) {
      var len = enc[0].encodingLength(obj.status)
      length += 1 + len
    }
    if (defined(obj.values)) {
      var len = enc[0].encodingLength(obj.values)
      length += 1 + len
    }
    if (defined(obj.lp)) {
      var len = enc[1].encodingLength(obj.lp)
      length += 1 + len
    }
    if (defined(obj.ch)) {
      var len = enc[2].encodingLength(obj.ch)
      length += 1 + len
    }
    if (defined(obj.chp)) {
      var len = enc[2].encodingLength(obj.chp)
      length += 1 + len
    }
    if (defined(obj.high_price)) {
      var len = enc[1].encodingLength(obj.high_price)
      length += 1 + len
    }
    if (defined(obj.low_price)) {
      var len = enc[1].encodingLength(obj.low_price)
      length += 1 + len
    }
    if (defined(obj.volume)) {
      var len = enc[1].encodingLength(obj.volume)
      length += 1 + len
    }
    if (defined(obj.rtc)) {
      var len = enc[1].encodingLength(obj.rtc)
      length += 1 + len
    }
    if (defined(obj.rch)) {
      var len = enc[2].encodingLength(obj.rch)
      length += 1 + len
    }
    if (defined(obj.rchp)) {
      var len = enc[2].encodingLength(obj.rchp)
      length += 1 + len
    }
    if (defined(obj.bid)) {
      var len = enc[2].encodingLength(obj.bid)
      length += 1 + len
    }
    if (defined(obj.ask)) {
      var len = enc[2].encodingLength(obj.ask)
      length += 1 + len
    }
    if (defined(obj.bid_size)) {
      var len = enc[2].encodingLength(obj.bid_size)
      length += 2 + len
    }
    if (defined(obj.ask_size)) {
      var len = enc[2].encodingLength(obj.ask_size)
      length += 2 + len
    }
    if (defined(obj.rest)) {
      var len = enc[0].encodingLength(obj.rest)
      length += 2 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.session)) {
      buf[offset++] = 10
      enc[0].encode(obj.session, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.symbol_name)) {
      buf[offset++] = 18
      enc[0].encode(obj.symbol_name, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.status)) {
      buf[offset++] = 26
      enc[0].encode(obj.status, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.values)) {
      buf[offset++] = 34
      enc[0].encode(obj.values, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.lp)) {
      buf[offset++] = 41
      enc[1].encode(obj.lp, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.ch)) {
      buf[offset++] = 53
      enc[2].encode(obj.ch, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.chp)) {
      buf[offset++] = 61
      enc[2].encode(obj.chp, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.high_price)) {
      buf[offset++] = 65
      enc[1].encode(obj.high_price, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.low_price)) {
      buf[offset++] = 73
      enc[1].encode(obj.low_price, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.volume)) {
      buf[offset++] = 81
      enc[1].encode(obj.volume, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.rtc)) {
      buf[offset++] = 89
      enc[1].encode(obj.rtc, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.rch)) {
      buf[offset++] = 101
      enc[2].encode(obj.rch, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.rchp)) {
      buf[offset++] = 109
      enc[2].encode(obj.rchp, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.bid)) {
      buf[offset++] = 117
      enc[2].encode(obj.bid, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.ask)) {
      buf[offset++] = 125
      enc[2].encode(obj.ask, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.bid_size)) {
      buf[offset++] = 133
      buf[offset++] = 1
      enc[2].encode(obj.bid_size, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.ask_size)) {
      buf[offset++] = 141
      buf[offset++] = 1
      enc[2].encode(obj.ask_size, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.rest)) {
      buf[offset++] = 154
      buf[offset++] = 1
      enc[0].encode(obj.rest, buf, offset)
      offset += enc[0].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      session: "",
      symbol_name: "",
      status: "",
      values: "",
      lp: 0,
      ch: 0,
      chp: 0,
      high_price: 0,
      low_price: 0,
      volume: 0,
      rtc: 0,
      rch: 0,
      rchp: 0,
      bid: 0,
      ask: 0,
      bid_size: 0,
      ask_size: 0,
      rest: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.session = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 2:
        obj.symbol_name = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 3:
        obj.status = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 4:
        obj.values = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 5:
        obj.lp = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 6:
        obj.ch = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 7:
        obj.chp = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 8:
        obj.high_price = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 9:
        obj.low_price = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 10:
        obj.volume = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 11:
        obj.rtc = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 12:
        obj.rch = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 13:
        obj.rchp = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 14:
        obj.bid = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 15:
        obj.ask = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 16:
        obj.bid_size = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 17:
        obj.ask_size = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 19:
        obj.rest = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineset_auth_token () {
  var enc = [
    encodings.string
  ]

  set_auth_token.encodingLength = encodingLength
  set_auth_token.encode = encode
  set_auth_token.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.token)) {
      var len = enc[0].encodingLength(obj.token)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.token)) {
      buf[offset++] = 10
      enc[0].encode(obj.token, buf, offset)
      offset += enc[0].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      token: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.token = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
